# 面试题

1.spring中的@Autowired和@Resource的区别
    @Autowired是由spring提供的，可以对构造方法，成员变量以及方法参数上进行标注，可以根据对象类型进行自动注入
    @Resource  作用和Autowired差不多，但是适用与所有的java框架，支持对象类型的注入，也支持对象名称的注入
@Autowired和@Resource的区别
   1.@Autowired内部只有1个required参数   默认为true,表示开启默认注入，@Resource包含7个参数 主要一个是名字name 和type
   2.@Autowired 支持优先注入，可以配置运行bean不存在
   3.@Autowired按byType自动注入，而@Resource默认按 byName自动注入。
2.spring的循环依赖 




3.spring ioc 

ioc 启动的时候就把所有的类创建到容器中，需要使用的时候通过注解去调用

4.aop工作

1日志，2.返回值

5.spingboot和springcloud的区别

springboot：相当于一个独立的，可以直接打包成jar进行运行的，简化了平时开发，比如ssm需要手动引入一些配置文件，

springcloud: springcloud的相当于一个生态，将srpingboot开发的一个个单体进行整合管理起来。包含一些注册中心，网关，熔断 hyginx sentinel 这些

6.注册中心

7.熔断降级

熔断   配置了一个错误率 50%  10个请求超过了错误率就会进行熔断， 或者说是服务器报错了，熔断了以后

8.hystrix线程池

9.网关 zuul->gateway

gateway 线程模型  

为什么用gateway

 没有用网关，一个服务一个ip 相当于对网关进行整合，只用调用一个就行，也可以做一些鉴权 ，做一个限流，超过1000 就直接关了  

10.sentinel底层算法

限流的算法，5000个请求放到mq里面 进行一个匀速的传输，

11.线程池

12.mq数据量比较大，怎么保证消息不丢失

13.spring事务没生效

13.用的设计模式

14.八种数据类型

15.包装类 integer  1000 和int  1000  是不是相等 


16.equip 和 == 的区别

String s = null;
　　会抛出NullPointerException异常的有(A,C)。[两项]

　　A) if( (s!=null) & (s.length()>0) )

　　B) if( (s!=null) & & (s.length()>0) )

　　C) if( (s==null) | (s.length()==0) )

　　D) if( (s==null) || (s.length()==0) )






17.索引理解
sql优化的时候 建立一个索引->执行效率变快->
索引：数据库表的目录
hash索引  

java 8 链表转换成一个树

有序数组
可以用二分 查得很快
但是crud很快，但是数据量很大的  就需要批量处理，速度不快


avl树 平衡树
左右 子树 不能相差1-》自旋 浪费性能

红黑树
红黑，但是不能村存很多


b+树  log n 复杂度
节点存储多个值  索引就是存在磁盘里面，


主键 id自增
避免分裂



18.bean是怎么注入的

19.try catch是干嘛的怎么实现的

throw可以抛异常 Error，Throwable，Exception，RuntimeException 但是Event和Object不能抛出 
以下对异常的描述不正确的有(C)

　　A) 异常分为Error和Exception

　　B) Throwable是所有异常类的父类

　　C) Exception是所有异常类父类

　　D) Exception包括RuntimeException和RuntimeException之外的异常
在try-catch-finally语句块中，以下可以单独与finally一起使用的是( try)

　　24. 以下描述不正确的有(D)

　　A) try块不可以省略

　　B) 可以使用多重catch块

　　C) finally块可以省略

　　D) catch块和finally块可以同时省略


20.list arrlist 能不能被实例

1、ArrayList的实现是基于数组，LinkedList的实现是基于双向链表。

2、对于随机访问，ArrayList优于LinkedList

3、对于插入和删除操作，LinkedList优于ArrayList

4、LinkedList比ArrayList更占内存，因为LinkedList的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。

LinkedList继承AbstractSequentialList类 实现了List接口

AbstractSet继承AbstractCollection类    实现了Set接口，

WeakHashMap 继承AbstractMap类   实现了Map接口

HashSet继承AbstractSet类              实现了Set接口。



21.aop的业务，干了什么

22.大杯子33l  小杯子5l 要得到7L的水

   用小杯子的倍数不断去取余  5*5-33=2l    2+5=7l

23.抽象类和接口的区别

抽象类和方法 就 是以**abstract修饰的方法和类**

1.抽象类中可以有普通成员变量，接口中没有普通成员变量

2.抽象类可以有构造方法，接口中不能有构造方法

3.抽象类中可以包含静态方法，接口中不能包含静态方法

4.抽象类中的抽象方法的访问类型可以是 public，protected ,但接口中的抽象方法只能是 public 类型的，并且默认即为 public abstract 类型

5.一个类可以实现多个接口，但只能继承一个抽象类。

6.抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只是public static final 类型，并且默认即为 public static final 类型。

 24.怎么把字符串反转

​    abcde 反转成edcba

1.字符串反转函数

```
  // StringBuffer
  public static String reverse1(String str) {
    return new StringBuilder(str).reverse().toString();
  }
```

2.一个一个进行反转

```
  // toCharArray
  public static String reverse2(String str) {
    char[] chars = str.toCharArray();
    String reverse = "";
    for (int i = chars.length - 1; i >= 0; i--) {
      reverse += chars[i];
    }
    return reverse;
  }
```

3.直接从中间移动

```
public static String reverse(String s) {
    char[] chars = s.toCharArray();
    for (int i = 0; i < chars.length / 2; i++) {
      char temp = chars[i];
      chars[i] = chars[chars.length - 1 -i];
      chars[chars.length - 1 - i] = temp;
    }
    return String.valueOf(chars);
  }
```

 25.sql语句练习

name   kecheng   fenshu
张三     语文       81
张三     数学       75
李四     语文       76
李四     数学       90
王五     语文       81
王五     数学       100
王五     英语       90
————————————————

1.查询每门课都大于  80分的姓名()

select   distinct  name from test where name not in（select distinct name from score where score<=80）

 2.按总成绩来排名 输出名字和总成绩

select name, dense_rank() over (order by Score desc) as 'Rank' from Scores

26.重写和重载的区别

子类继承父类，对他原来的方法进行改写，重载就是定义了不同的方法，函数名相同，只是参数列表不同，


27.继承，封装，多态
继承：子类继承父类，实现父类中的属性和方法，
封装：把一些操作封装成一个方法，实现代码的复用
多态：继承之间的关系调用，通过调用不同的子类对象完成不同的功能
条件有3个： 1.继承 2.重写 3.子类可以赋给父类引用 


28.序列化和反序列化
序列化：把Java对象转换为字节序列的过程。
反序列：把字节序列恢复为Java对象的过程。
序列化是什么：java对象是在JVM中生成的，是内存中的数据，如果需要把对象的字节序列远程传输或保存到硬盘上时，
你就需要将Java对象转换成二进制流。 这个转换过程就是序列化。 假如别人传给你一个二进制流数据，
当你想要恢复成内存中的对象时，你就需要反序列化
 序列化的原因：网络通信时，无论是何种类型的数据，都会转成字节序列的形式在网络上传送。
发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。
就比把对象封装成json格式(字符流)
 实现序列化： Serializable    Externalizable

redis的5种类型
string hash list set zset有序集合


怎么实现sentinel
通过阿里云的sentinel,
1.直接增加流控规则 超过多少就直接把他关了
2.增加关联模型 当关联的资源达到阀值的时候就限流自己   就可以避免一大串的请求导致服务雪崩 ，影响后面的请求
3.预热  直接升 1s 10w可能把系统直接干没，设置流控 让他20s缓冲期， 预热到100 每秒3(默认冷加载因子) 100/3
降级规则(熔断)
热点规则（热点参数限流）
根据热点带来的参数进行限流，找到关键字testHotKey  如果违背了就走blockHandler 相当于一个兜底方法，
自定义限流处理创建一个CustomerBlockHandler按照自定义兜底方法的来进行解耦
